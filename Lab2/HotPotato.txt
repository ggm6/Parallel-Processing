Name: Garrett McDonnell
IPP Hot Potato

NOTE: I used sublime in linux to write this quickly, so I have no idea if this equates to a full page as a .doc file.

	I start the program by declaring and initializing some variables.  Those are rank and size, which are used to initialize each of the nodes, and so each node knows the total size of the Comm is 12.
The potatoTimer variable is initialized to a random integer between 12 and 42.  I seed rand with time(0).  In future programs, I will likely use some other method to generate random numbers, as all
these processes are running in parellel and are more likely to generate similar numbers.  I also have a node variable to determine where the potato will be sent to next, it starts as -1 until the program determines if and when that process will send the potato.  I also have a markStart variable, which is set to "true" in all processes, if rank is 0, it is used to mark the start of the potato game, the game start message is output, and variable set to "false".  It will remain "false" for the rest of the program in Node 0 and is not used anywhere else in the program.  The last variable I use is prevNode, which is set to -1 at the beginning of each while-loop, this variable is changed in a block containing code that will determine the next node to send the potato to.  This is useful, because I first set the next node, but I still need prevNode to set the source on the MPI_Recv near the end of the while-loop. 

	The structure of each process executes in a while-loop that terminates when potatoTimer reaches -1, each processes continues until this condition is met, and then I call MPI_Finalize() to finish the program.  potatoTimer decrements at the end of the loop in all processes, and I set a barrier there so that they all will cut the loop at roughly the same time.  Another tactic I found to be useful was to set a barrier after any block containing a cout statement, so that the display will show the potato being passed around in order.

	In this while-loop, I first check for rank==0 and to see if markStart==true.  This means that for Node 0, on the first run of the loop, the block triggers, I calculate the node to send to using rand() again, I set prevNode to 0 (as this is the containing Node), and I cout a statement indicating the start of the game.  The barrier is used so that the very first cout statement will be from Node 0 showing the start of the game, indefinitely.  For every following iteration of the while-loop, an if-statement checks to see if that process's rank is the same as node, meaning that we are in the process that the potato was sent to.  I set prevNode to that node, if this is the case.  I first check to see if potatoTimer==0, which then outputs the game-finish message.  Otherwise, I output that we are sending the potato from this node, I calculate the next node, and output that we are sending the potato to that node.  I set another barrier, because one of those cout statements is going to execute, indefinitely, if the process makes it to that if-statement.  Finally, I check to see if prevNode is the current process, and in the process that this occurs, I send the new calculated node to every process except the containing process.  Else, I receive this node from MPI_ANY_SOURCE.  I set one last barrier to make sure they all finish at the same value of potatoTimer, just to maintain the illusion of the game itself.  Finally, I call MPI_Finalize() and the program ends.